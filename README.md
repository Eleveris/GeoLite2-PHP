# GeoLite2-PHP
GeoLite2 Integration Demo

# Общая структура проекта

## Методы сервиса

Сервис поддерживает 2 вида запросов:
1. `/?ip={ip}` или `/remote?ip={ip}` На API сервиса GeoLite2
2. `/local?ip={ip}` К локальной БД GeoLite2 (БД должна быть предоставлена, автоматического получения нет)

Позитивный ответ имеет вид:
```json
{
    "result": {
        "ip": "2001:0000:130F:0000:0000:09C0:876A:1307",
        "country": "US",
        "fresh": true
    }
}
```
- ip - полученный на вход ip адрес
- country - двухбуквенный код страны от сервиса GeoIP
- fresh - был ли ответ получен от сервиса (`true`) или из кэша (`false`)

Негативный ответ имеет вид:
```json
{
    "error": "Параметр ip не является валидным ip адресом",
    "errcode": 500
}
```
- error - текст ошибки
- errcode - код ошибки (http), который дублируется как http code в заголовке ответа

## Общее

Архитектурно в базе лежит MVC без View (потому что api) + набор синглтонов для доступа к внешним сервисам.

Запрос к API GeoIP2 выполняется напрямую Guzzle запросом т.к. запрос через Web Client библиотеки сваливается в "Invalid handle provided" где-то глубоко в недрах Curl. Около часа консультаций с гуглом не дало никаких результатов.

В ходе разработки использовался php-cs-fixer с rule set PSR-2, который глобально устарел, но учитывая архитектурную простоту проекта - более чем достаточен.

# Зависимости

### Модуль `vlucas/phpdotenv`
Упрощает работу с env файлами.

### Модуль `slim/slim` `slim/psr7`
Относительно легковесный роутер. В целом в нём нет необходимости и можно было обойтись стандартными средствами PHP, но я более привычен использовать Slim так что для скорости взял его.

### Модуль `guzzlehttp/guzzle`
Стандартный вариант для формирования HTTP запросов к внешним сервисам. Опять же, может быть слегка избыточно, но мне с ним комфортнее работать.

### Модуль `geoip2/geoip2`
Официальная библиотека для работы с файлами mmdb.

# Контейнеры

Простая пара контейнеров из nginx и PHP-FPM. Глобально php-fpm работает лучше под нагрузкой чем классическая связка Apache+PHP и nginx шустрее работает как reverse-proxy чем Apache.

PHP-FPM базируется на Debian Bullseye и так же содержит внутри Memcached. Если скейлить горизонтально, то имеет смысл вынести Memcached в отдельный контейнер конечно же, но для горизонтального скейлинга потребуется K8s или network discovery и я не админ для такого.

PHP-FPM и Memcached запускаются как сервисы через runit так же на PHP-FPM есть health check на уровне контейнера.

Так как контейнер маунтится на директорию, то любые изменения в исходниках сразу доступны в сервисе, потому что это контейнер для разработки, для деплоймента исходники должны зашиваться в image во избежании нежелательных случайностей.

## Конфигурация и запуск

Из файла `.env.example` в `./src/config` следует сформировать `.env` файл с настройками.

Для настройки Memcached доступен файл `/rootfs/etc/memcached.conf`

В `/rootfs/usr/local/etc/php` доступны настройки PHP_FPM. Основной конфиг довольно стандартный и всё реальные настройки находятся в файлах `*.d` директорий

В `/nginx` доступны настройки nginx. Непосредственная конфигурация сервера nginx находится в `/nginx/conf.d/default.conf`

Для смены рабочего порта следует изменить порт в `docker-compose.yml` в сервисе nginx. По умолчанию работает на порту 8080.

Для запуска потребуется docker compose. Запуск выполняется `docker compose up -d` или `docker compose up --build -d` если требуется пересобрать контейнер.